<?php

namespace App;

use Illuminate\Notifications\Notifiable;
use Illuminate\Foundation\Auth\User as Authenticatable;

use Illuminate\Support\Facades\Auth;
use App\Status;

use App\Notifications\ResetPassword;


class User extends Authenticatable
{
    use Notifiable;

    /**
     * The attributes that are mass assignable.
     * 定义可以组合赋值的字段
     *
     * @var array
     */
    protected $fillable = [
        'name', 'email', 'password',
    ];

    /**
     * The attributes that should be hidden for arrays.
     *
     * @var array
     */
    protected $hidden = [
        'password', 'remember_token',
    ];

    //User显示模型头像的方法
    public function gravatar($size = '100')
    {
        $hash = md5(strtolower(trim($this->attributes['email'])));
        return "http://www.gravatar.com/avatar/$hash?s=$size";
    }

    //在一个User模型创建是会执行的代码（创建一个随机生成的长30的字符串保存在新建模型的activation_token字段上，即随用户的创建随机生成一个激活账户所用的激活字段）
    public static function boot()
    {
        parent::boot(); // TODO: Change the autogenerated stub
        static::creating(function ($user){
            $user->activation_token = str_random(30);
        });
    }

    /**
     * 关联其他模型
     *
     * Eloquent 会基于模型名决定外键名称
     * 如果你想修改一个关联模型中所默认使用的外键，可以修改一个关联函数的第二个参数（值是关联模型中的字段）
     * Eloquent 假设外键的值是与父级 id（或自定义 $primaryKey）列的值相匹配的 。换句话说，Eloquent 将会在 Phone 记录的 user_id 列中查找与用户表的 id 列相匹配的值。 如果您希望该关联使用 id 以外的自定义键名，则可以给 hasOne 方法传递第三个参数
     *  也就是说如果你想让一个关联模型关联到本模型默认关联的主键之外的另外字段，可以修改关联函数的第三个参数（值是本模型中的字段）
     *================================================================================
     * 定义反向关联
     * 我们能从本模型访问到说所关联的模型，当然我们也能从关联模型访问到本模型，在关联模型中定义一个反向关联即可
     *================================================================================
     * 默认模型
     * belongsTo 关联允许定义默认模型，这适应于当关联结果返回的是 null 的情况。这种设计模式通常称为 空对象模式，为您免去了额外的条件判断代码。在下面的例子中，user 关联如果没有找到文章的作者，就会返回一个空的 App\User 模型。
     * 获得此文章的作者
     *  public function user()
        {
            return $this->belongsTo('App\User')->withDefault();
        }
     *还可以给默认模型赋值
     *public function user()
    {
        return $this->belongsTo('App\User')->withDefault([
            'name' => '游客',
        ]);
    }

    public function user()
    {
        return $this->belongsTo('App\User')->withDefault(function ($user) {
            $user->name = '游客';
        });
    }
     *
     *
     *================================================================================
     * 一对一
     * $this->hasOne('模型');
     * 反向（多对一）
     * $this->belongsTo('模型');
     *================================================================================
     * 一对多
     *$this->hasMany('模型');
     *反向（多对一）
     * $this->belongsTo('模型');
     *================================================================================
     * 多对多（需要一个中间表）
     * $this->belongsToMany('模型');
     *为了确定关联连接表表名， Eloquent 会按照字母顺序合并两个关联模型的名称。当然，你也可以不使用这种约定，传参给 belongsToMany 方法的第二个参数
     *    第二个参数就是多对多关联成立的中间表表名
     * 除了自定义连接表表名外，你还可以通过给 belongsToMany 方法传递其它参数来自定义连接表的键名。第三个参数是定义此关联的模型在连接表里的外键名，第四个参数是另一个模型在连接表里的外键名
     *
     * 中间表（ pivote ）
     *获取中间表字段
     * 调用定义的多对多方法返回的是模型实例的数组，可以对每个模型默认调用->pivot方法来获取中间表的模型(Eloquent 模型)
     * 自定义 pivot 属性名称
     *      能在多对多关联的时候使用->as('otherMethod')将中间访问器重命名为otherMethod
     * 通过中间表列过滤关系
     * 在定义关系时，还能使用 wherePivot 和 wherePivotIn 方法来过滤 belongsToMany 返回的结果
     * 定义自定义中间表模型
     *     如果想定义一个自定义模型来表示关联关系中的中间表，可以在定义关联调用 using 方法。
     *     所有自定义中间表模型都必须扩展自 Illuminate\Database\Eloquent\Relations\Pivot 类
     *================================================================================
     * 远程一对多
     * $this->hasManyThrough()  方法定义远程一对多
     * hasManyThrough 方法的第一个参数是我们最终希望访问的模型名称，而第二个参数是中间模型的名称
     *     远程一对多实现的是通过一个中间模型最终获取到一个没有关联本模型外键的一个模型
     * 自定义关联的键，可以通过第三个和第四个参数实现
     * 第五个参数表示本地键名，而第六个参数表示中间模型的本地键名
        public function posts()
        {
            return $this->hasManyThrough(
            'App\Post',
            'App\User',
            'country_id', // 用户表外键...
            'user_id', // 文章表外键...
            'id', // 国家表本地键...
            'id' // 用户表本地键...
            );
        }
     *
     *================================================================================
     * 多态关联
     *  多态关联允许一个模型在单个关联上属于多个其他模型。例如，想象一下使用您应用的用户可以「评论」文章和视频。使用多态关联，您可以用一个 comments 表同时满足这两个使用场景。让我们来看看构建这种关联所需的数据表结构：
    posts
    id - integer
    title - string
    body - text

    videos
    id - integer
    title - string
    url - string

    comments
    id - integer
    body - text
    commentable_id - integer
    commentable_type - string

    comments 表中有两个需要注意的重要字段 commentable_id 和 commentable_type。commentable_id 用来保存文章或者视频的 ID 值，而 commentable_type 用来保存所属模型的类名。commentable_type 是在我们访问 commentable 关联时， 让 ORM 确定所属的模型是哪个「类型」。
     *
     * $this->morphTo();
     * $this->morpMany('模型', '模型的方法');
     *创建这种关联所需的模型定义：
     * <?php
        namespace App;
        use Illuminate\Database\Eloquent\Model;
        class Comment extends Model
        {
        /**
         * 获得拥有此评论的模型。
        public function commentable()
        {
            return $this->morphTo();
        }
        }

        class Post extends Model
        {
            /**
             * 获得此文章的所有评论。
            public function comments()
            {
                return $this->morphMany('App\Comment', 'commentable');
            }
        }

        class Video extends Model
        {
            /**
             * 获得此视频的所有评论。
            public function comments()
            {
                return $this->morphMany('App\Comment', 'commentable');
            }
        }
     * Comment 模型的 commentable 关联会返回 Post 或者 Video 实例，这取决于评论所属的模型类型。
     *
     *
     * 自定义多态关联的类型字段
     * 默认 Laravel 会使用完全限定类名作为关联模型保存在多态模型上的类型字段值，比如上面的例子中， Comment 属于 Post 或者 Video ，那么 comment_type 的默认值对应的就是 App\Post 和 App\Video
     * 可能希望将数据库与程序内部结构解耦。那样的话，你可以定义一个「多态映射表」来指示 Eloquent 使用每个模型自定义类型字段名而不是类名：

        use Illuminate\Database\Eloquent\Relations\Relation;

        Relation::morphMap([
        'posts' => 'App\Post',
        'videos' => 'App\Video',
        ]);

     *您可以在 AppServiceProvider 中的 boot 函数中使用 Relation::morphMap 方法注册「多态映射表」，或者使用一个独立的服务提供者注册。
     *
     *================================================================================
     * 多对多多态关联
     * $this->morpToMany('模型', '表');
     * 要正常使用还需要在'模型'中定义一个反向关联
     * $this->>morphedByMany('其他模型', '表')
     * 通过本模型获调用方法获取其他的多个模型，对其他的多个模型还能调用访问另外的模型
     *
     *
     */

    //该方法获取用户的statuses（微博信息）关联User模型的和Status模型，一对多关系绑定 hasMany()
    public function statuses()
    {
        return $this->hasMany(Status::class);
    }

    //该方法获取用户的追随者，关联User模型与User模型，呈多对多关系
    public function followers()
    {
        return $this->belongsToMany(User::class, 'followers', 'follower_id', 'user_id');
    }
    //该方法获取用户的关注者，关联User模型，多对多关系，使用中间表‘followers’
    public function followings()
    {
        return $this->belongsToMany(User::class, 'followers', 'user_id', 'follower_id');
    }

    public function follow($user_ids)
    {
        if (!is_array($user_ids)){
            $user_ids = compact('user_ids');
        }
        $this->followings()->sync($user_ids, false);
    }

    public function  unfollow($user_ids)
    {
        if (!is_array($user_ids)){
            $user_ids = compact('user_ids');
        }
        $this->followings()->detach($user_ids);
    }

    public function isFollowing($user_id)
    {
        return $this->followings->contains($user_id);
    }

    public function feed()
    {
        $user_ids = Auth::user()->followings->pluck('id')->toArray();
        array_push($user_ids, Auth::user()->id);
        return Status::whereIn('user_id', $user_ids)->with('user')->orderBy('created_at', 'desc');
    }

    public function sendPasswordResetNotification($token)
    {
        $this->notify(new ResetPassword($token));
    }
}
